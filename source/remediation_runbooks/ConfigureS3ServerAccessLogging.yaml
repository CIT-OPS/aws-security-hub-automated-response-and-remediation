description: |
  ### Document Name - AWSConfigRemediation-ConfigureS3ServerAccessLogging

  ## What does this document do?
  This document is used to create or modify an Amazon S3 bucket for the s3 access logs in this account and region.  If the bucket already exists,
  then no error is thrown and the bucket will be used as a destination of this finding resource bucket access logs.

  ## Input Parameters
  * BucketName: (Required) Name of the S3 bucket (not the ARN).
  * DestBucketName: (Required) Name of the S3 bucket to write the logs to (not the ARN)
  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

  ## Output Parameters
  * GetBucketPublicAccessBlock.Output - JSON formatted response from the GetPublicAccessBlock APAfI call
schemaVersion: '0.3'
assumeRole: '{{ AutomationAssumeRole }}'
outputs:
  - RemediateTargetBucket.Output
parameters:
  Finding:
    type: StringMap
  Resource:
    type: StringMap
  AutomationAssumeRole:
    type: String
    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
    allowedPattern: '^arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/[\w+=,.@-]+'
mainSteps:
  - name: CreateDestinationBucket
    action: 'aws:executeScript'
    description: |
      ## CreateDestinationBucket
      Creates the S3 Log destination bucket if needed.
      ## Outputs
      * Output: NoneA
    isEnd: false
    inputs:
      Runtime: python3.8
      Handler: lambda_handler
      InputPayload:
        Finding: '{{ Finding }}'
        Resource: '{{ Resource }}'
      Script: |-
        import logging
        import boto3
        from botocore.exceptions import ClientError

        def create_bucket(s3, bucket_name, region):
          """Create an S3 bucket in a specified region

          If a region is not specified, the bucket is created in the S3 default
          region (us-east-1).

          :param bucket_name: Bucket to create
          :param region: String region to create bucket in, e.g., 'us-west-2'
          :return: True if bucket created, else False
          """

          # Create bucket
          try:
            if region != 'us-east-1':
                bucket = s3.create_bucket(
                  Bucket=bucket_name,
                  ACL='private',
                  CreateBucketConfiguration={ 
                    'LocationConstraint': region
                  },
                  ObjectLockEnabledForBucket=False,
                  ObjectOwnership='BucketOwnerEnforced'
                ) 
                logging.info(bucket)
            else:
                bucket = s3.create_bucket(
                  Bucket=bucket_name,
                  ACL='private',
                  ObjectLockEnabledForBucket=False,
                  ObjectOwnership='BucketOwnerEnforced'
                ) 
                logging.info(bucket)
            
            s3_client = boto3.client("s3")
            response = s3_client.put_bucket_encryption(
                Bucket=bucket_name,
                ServerSideEncryptionConfiguration={
                    "Rules": [
                        {"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}
                    ]
                },
            )   
            response = s3_client.put_bucket_versioning(
                Bucket=bucket_name,
                VersioningConfiguration={
                    'Status': 'Enabled'
                },
            )
            
          except ClientError as e:
            logging.error(e)
            return False
          return True


        def lambda_handler(event, context):
          s3 = boto3.resource("s3")
          resourceId = event["Resource"]['Id']
          region = event["Resource"]["Region"]
          bucketArray = resourceId.split(":")
          AwsAccountId = event["Finding"]['AwsAccountId']
          bucket = 'cnxc-s3-server-access-logging-' + AwsAccountId + '-' + region
          

          # Create Bucket
          if create_bucket(s3, bucket, region):
            return bucket
          else:
            return 'failed'
    isCritical: true
    maxAttempts: 2
    timeoutSeconds: 600
  - name: RemediateTargetBucket
    action: 'aws:executeScript'
    description: |
      ## GetBucketPublicAccessBlock
      XXXXXX
      ## Outputs
      * Output: JSON formatted response from the XXXXXX call.
    timeoutSeconds: 600
    isCritical: true
    isEnd: true
    inputs:
      Runtime: python3.8
      Handler: lambda_handler
      InputPayload:
        Finding: '{{Finding}}'
        Resource: '{{Resource}}'
      Script: |-
        import logging
        import copy
        import json
        import time
        from pprint import pprint
        import botocore
        import boto3


        def get_bucket_acl(client, storageBucket):
            return client.get_bucket_acl(
            Bucket=storageBucket,
        )

        def set_bucket_acl(client, storageBucket, modified_acl):
            return client.put_bucket_acl(
                Bucket=storageBucket,
                AccessControlPolicy=modified_acl
            )


        def enableAccessLogging(s3, bucketName, storageBucket, targetPrefix):
          # Get the existing policy document
          # Retrieve the policy of the specified bucket
          
          bucketArn = 'arn:aws:s3:::'+bucketName+'/*'
          matched = False
          statements = []
          try:
            result = s3.get_bucket_policy(Bucket=bucketName)
            policy = eval(result['Policy'])
            statements = policy['Statement']
            for statement in statements:

              try:
                if statement['Principal']['Service'] == 'logging.s3.amazonaws.com' and statement['Resource'] == bucketArn:
                  matched = True
              except:
                  pass
            
          except botocore.exceptions.ClientError as error:
            print(error.response['Error']['Code'])
            print('Creating a new policy')
            policy = json.loads('{ "Id": "ExamplePolicy", "Version": "2012-10-17",      "Statement": [{ "Sid": "AllowSSLRequestsOnly","Action": "s3:*","Effect": "Deny","Resource": ["arn:aws:s3:::'+bucketName+'",            "arn:aws:s3:::'+bucketName+'/*"          ],          "Condition": {            "Bool": {              "aws:SecureTransport": "false"            }          },          "Principal": "*"        }      ]    }')
            statements = []
            
          if matched:
            print(bucketName+ ' already has a policy statement to allow logging.s3.amazonaws.com')
          else:
            print('Adding to policy')
            newStatement = json.loads('{"Sid": "SHARRS3PolicyStmt-DO-NOT-MODIFY-'+str(int(time.time()))+'",      "Effect": "Allow",      "Principal": {        "Service": "logging.s3.amazonaws.com"      },      "Action": "s3:PutObject",      "Resource": "arn:aws:s3:::'+bucketName+'/*"    }')
            statements.append(newStatement)
            policy['Statement'] = statements
            
            # Convert the policy from JSON dict to string
            bucket_policy = json.dumps(policy)
            
            # Set the new policy
            s3.put_bucket_policy(Bucket=bucketName, Policy=bucket_policy)

          return s3.put_bucket_logging(
              Bucket=bucketName,
              BucketLoggingStatus={
                  'LoggingEnabled': {
                      'TargetBucket': storageBucket,
                      'TargetPrefix': targetPrefix
                  }
              }
          )

        def lambda_handler(event, context):
          s3_client = boto3.client("s3")
          s3 = boto3.resource("s3")
          resourceId = event["Resource"]['Id']
          region = event["Resource"]["Region"]
          bucketArray = resourceId.split(":")
          fixmeBucket = bucketArray[-1]
          AwsAccountId = event["Finding"]['AwsAccountId']
          destBucket = 'cnxc-s3-server-access-logging-' + AwsAccountId + '-' + region
          targetPrefix = fixmeBucket+'/'
          
          print(fixmeBucket, destBucket, targetPrefix)
          if fixmeBucket == destBucket:
          return {
            "output":
              {
                "message": "Exception Silly Rabbit!  Logging access from this bucket to this bucket will create a circular out of control loop!",
                "resourceBucketName": fixmeBucket,
                "LoggingBucketName": destBucket,
                "LoggingPrefix": targetPrefix
              }
          }
          
          
          output = enableAccessLogging(s3_client, fixmeBucket, destBucket, targetPrefix)
          return {
            "output":
              {
                "message": "Server Access Logging Successfully Set.",
                "resourceBucketName": fixmeBucket,
                "LoggingBucketName": destBucket,
                "LoggingPrefix": targetPrefix
              }
          }
    outputs:
      - Name: Output
        Selector: $.Payload.output
        Type: StringMap
